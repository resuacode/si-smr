---
title: Copias de Seguridad e Imágenes de Respaldo
sidebar_position: 3
---

# Copias de Seguridad e Imágenes de Respaldo

Las copias de seguridad son fundamentales para proteger la información frente a pérdidas, daños o accesos no autorizados. En esta sección, exploraremos las diferentes estrategias y métodos para realizar copias de seguridad efectivas, así como la creación y restauración de imágenes de respaldo de sistemas en funcionamiento.

En esta sección se cubrirán los siguientes temas:

   - Estrategias para la realización de copias de seguridad:
      - Total
      - Incremental
      - Diferencial
   - Frecuencia y esquema de rotación:
      - Torre de Hanói
      - GFS
   - Realización de copias de seguridad
   - Creación y restauración de imágenes de respaldo de sistemas en funcionamiento

## Estrategias para la realización de copias de seguridad

Existen varias estrategias para realizar copias de seguridad, cada una con sus propias ventajas y desventajas:  

### Copia de seguridad total (Full Backup)

Una copia de seguridad total realiza una copia completa de todos los datos seleccionados. Es la estrategia más sencilla y la base de cualquier plan de copias de seguridad.

**Características:**
- Copia todos los archivos y carpetas seleccionados
- No depende de copias anteriores
- Mayor tiempo de ejecución y espacio de almacenamiento requerido
- Restauración más rápida y sencilla

**Cuándo utilizarla:**
- Como base inicial de cualquier esquema de copias
- En sistemas con datos críticos que cambian constantemente
- Cuando se dispone de amplio espacio de almacenamiento
- Antes de cambios importantes en el sistema

### Copia de seguridad incremental (Incremental Backup)

Solo se copian los datos que han cambiado desde la última copia de seguridad, ya sea total o incremental. Esta estrategia es la más eficiente en términos de tiempo y espacio.

**Características:**
- Copia solo los archivos modificados desde el último backup (total o incremental)
- Menor tiempo de ejecución y espacio requerido
- Requiere la copia completa más todas las incrementales para restaurar
- Más compleja de gestionar

**Ejemplo de secuencia:**
```
Domingo:    Copia TOTAL (100GB)
Lunes:      Incremental (+5GB desde domingo)
Martes:     Incremental (+3GB desde lunes)
Miércoles:  Incremental (+7GB desde martes)
```

Para restaurar el miércoles, se necesitan: Total + Inc.Lunes + Inc.Martes + Inc.Miércoles

### Copia de seguridad diferencial (Differential Backup)

Se copian todos los datos que han cambiado desde la última copia de seguridad total. Ofrece un equilibrio entre eficiencia y facilidad de restauración.

**Características:**
- Copia todos los archivos modificados desde la última copia TOTAL
- Tamaño crece progresivamente hasta la siguiente copia total
- Restauración más rápida que incremental (solo necesita total + última diferencial)
- Consume más espacio que incremental pero menos que total

**Ejemplo de secuencia:**
```
Domingo:    Copia TOTAL (100GB)
Lunes:      Diferencial (+5GB desde domingo)
Martes:     Diferencial (+8GB desde domingo)
Miércoles:  Diferencial (+15GB desde domingo)
```

Para restaurar el miércoles, solo se necesitan: Total + Diferencial del miércoles

### Comparativa de estrategias

| Característica | Total | Incremental | Diferencial |
|----------------|-------|-------------|-------------|
| **Tiempo de backup** | Alto | Bajo | Medio |
| **Espacio requerido** | Alto | Bajo | Medio |
| **Tiempo de restauración** | Bajo | Alto | Medio |
| **Complejidad** | Baja | Alta | Media |
| **Archivos necesarios** | 1 | Muchos | 2 |

### Estrategia combinada recomendada

La mejor práctica suele ser combinar las tres estrategias:

**Ejemplo de esquema semanal:**
- **Domingo**: Copia total
- **Lunes a Sábado**: Copias incrementales o diferenciales
- **Mensual**: Copia total de archivo

**Ventajas de la combinación:**
- Optimiza el uso del almacenamiento
- Balance entre tiempo de backup y restauración
- Múltiples puntos de recuperación
- Protección contra corrupción de backups

:::tip
Es recomendable evaluar periódicamente la estrategia de copias de seguridad para adaptarla a las necesidades cambiantes de la organización y asegurar la efectividad del plan de protección de datos.
:::

## Frecuencia y esquema de rotación

La frecuencia de las copias de seguridad y el esquema de rotación son aspectos cruciales para garantizar la protección de los datos. Un buen esquema de rotación optimiza el uso del almacenamiento mientras mantiene múltiples puntos de recuperación históricos.

### Esquema GFS (Grandfather-Father-Son)

El esquema **GFS** es el más utilizado en entornos empresariales. Utiliza tres niveles jerárquicos de copias de seguridad:

**Estructura del esquema:**
- **Hijo (Son)**: Copias diarias - se mantienen de 1 a 2 semanas
- **Padre (Father)**: Copias semanales - se mantienen de 4 a 8 semanas
- **Abuelo (Grandfather)**: Copias mensuales - se mantienen de 3 a 12 meses

**Ejemplo práctico de rotación GFS:**

```
Semana 1:
  Lunes:    Incremental (Hijo 1)
  Martes:   Incremental (Hijo 2)
  Miércoles: Incremental (Hijo 3)
  Jueves:   Incremental (Hijo 4)
  Viernes:  Incremental (Hijo 5)
  Sábado:   -
  Domingo:  Total (Padre - Semana 1)

Semana 2-4: (se repite el patrón)

Última semana del mes:
  Domingo:  Total (Abuelo - Mes X)
```

**Ventajas:**
- Balance entre protección y uso de almacenamiento
- Múltiples puntos de recuperación
- Cumple con requisitos de retención de datos
- Fácil de entender y gestionar

**Políticas de retención recomendadas:**
- Copias diarias: 7-14 días
- Copias semanales: 4-8 semanas
- Copias mensuales: 6-12 meses
- Copias anuales: 3-7 años (según requisitos legales)

### Esquema Torre de Hanói

El esquema **Torre de Hanói** es más complejo pero extremadamente eficiente en el uso de medios. Se basa en el algoritmo matemático del juego Torre de Hanói.

**Características:**
- Utiliza 5 o más cintas/medios rotatorios
- Cada medio tiene una frecuencia de uso diferente
- Proporciona múltiples versiones históricas
- Muy eficiente en uso de medios

**Ejemplo con 5 medios (A, B, C, D, E):**

| Día | Medio usado | Patrón |
|-----|-------------|---------|
| 1   | A | Se usa cada día |
| 2   | B | Se usa cada 2 días |
| 3   | A | |
| 4   | C | Se usa cada 4 días |
| 5   | A | |
| 6   | B | |
| 7   | A | |
| 8   | D | Se usa cada 8 días |
| 9   | A | |
| 10  | B | |
| 11  | A | |
| 12  | C | |
| 13  | A | |
| 14  | B | |
| 15  | A | |
| 16  | E | Se usa cada 16 días |

**Ventajas:**
- Máxima eficiencia de medios
- Múltiples puntos de recuperación históricos
- Menor costo en medios de almacenamiento

**Desventajas:**
- Complejidad en la gestión
- Difícil de explicar y mantener
- Requiere automatización para evitar errores

### Esquema 3-2-1

La regla **3-2-1** es una estrategia moderna de protección de datos que se centra en la redundancia y la diversificación.

**Principios:**
- **3** copias de los datos (original + 2 backups)
- **2** tipos diferentes de medios (por ejemplo: disco + nube)
- **1** copia fuera del sitio (off-site)

**Ejemplo de implementación:**

```
Copia 1 (Original): Servidor de producción
Copia 2 (Local):    NAS/Disco externo en la oficina
Copia 3 (Remota):   Almacenamiento en la nube (AWS/Azure/Google)
```

**Ventajas:**
- Protección contra múltiples escenarios de desastre
- Protección contra ransomware
- Cumple con mejores prácticas de la industria
- Relativamente simple de implementar

### Esquema 3-2-1-1-0 (Moderna ampliación)

Variante moderna que añade capas adicionales de protección:

- **3** copias de los datos
- **2** tipos diferentes de medios
- **1** copia fuera del sitio
- **1** copia inmutable/offline (air-gapped)
- **0** errores en las verificaciones de restauración

**Protección adicional:**
- Copia inmutable protege contra ransomware
- Copia offline (air-gapped) protege contra ataques sofisticados
- Verificación garantiza recuperabilidad

### Frecuencias recomendadas según tipo de datos

| Tipo de datos | Frecuencia mínima | Esquema recomendado |
|---------------|-------------------|---------------------|
| **Datos críticos** | Cada hora | Continuo + GFS |
| **Bases de datos** | 4-6 veces/día | Incremental + GFS |
| **Archivos de usuario** | Diaria | GFS o 3-2-1 |
| **Sistemas operativos** | Semanal | Imágenes + GFS |
| **Archivos históricos** | Mensual | Total + Archivado |

### Automatización y programación

**Herramientas de programación en Linux:**
- **cron**: Programador de tareas estándar
- **systemd timers**: Alternativa moderna a cron
- **anacron**: Para sistemas que no están 24/7

**Ejemplo de crontab para copias automáticas:**
```bash
# Copias incrementales diarias a las 2:00 AM
0 2 * * 1-6 /usr/local/bin/backup-incremental.sh

# Copia total los domingos a las 1:00 AM
0 1 * * 0 /usr/local/bin/backup-full.sh

# Verificación de backups a las 8:00 AM
0 8 * * * /usr/local/bin/backup-verify.sh
```

**Herramientas de programación en Windows:**
- **Programador de tareas** (Task Scheduler)
- **PowerShell scripts** con tareas programadas
- **Software de backup** con programación integrada

:::tip
Implementar un sistema de monitoreo y alertas para las copias de seguridad puede ayudar a identificar problemas inmediatamente y asegurar que las copias se realicen según lo planificado. Considera el uso de herramientas como Nagios, Zabbix o soluciones cloud-native para el monitoreo.
:::

## Realización de copias de seguridad

La realización de copias de seguridad implica varios pasos clave y el uso de herramientas especializadas para asegurar que los datos estén protegidos de manera efectiva.

### Proceso de planificación y ejecución

1. **Selección de datos**: Identificar los datos críticos que necesitan ser respaldados
   - Archivos de usuarios
   - Bases de datos
   - Configuraciones del sistema
   - Logs y auditorías
   - Aplicaciones y sus datos

2. **Elección del método de copia**: Decidir entre métodos locales o remotos
   - Locales: Discos duros, cintas, NAS
   - Remotos: Almacenamiento en la nube, sitios remotos
   - Híbridos: Combinación de local y remoto

3. **Programación de copias**: Establecer calendario considerando:
   - Ventanas de mantenimiento
   - Horarios de menor actividad
   - Frecuencia según criticidad
   - Esquema de rotación elegido

4. **Ejecución de copias**: Automatizar con software especializado

5. **Verificación de copias**: Validar integridad y recuperabilidad

6. **Almacenamiento seguro**: Proteger física y lógicamente

7. **Documentación**: Registro detallado de todas las operaciones

8. **Pruebas de restauración**: Validación periódica de recuperabilidad

### Herramientas de copia de seguridad

#### Herramientas en Linux

| Herramienta | Tipo | Descripción | Caso de uso |
|-------------|------|-------------|-------------|
| **rsync** | Sincronización | Copia incremental eficiente | Copias locales y remotas |
| **tar** | Archivado | Crea archivos comprimidos | Backups básicos |
| **dd** | Clonación | Copia bit a bit | Imágenes de disco completas |
| **Bacula** | Suite completa | Sistema cliente-servidor | Entornos empresariales |
| **Amanda** | Suite completa | Advanced Maryland Automatic Network Disk Archiver | Entornos grandes |
| **Duplicity** | Incremental | Backups cifrados incrementales | Copias a la nube |
| **Borgbackup** | Deduplicación | Backups con deduplicación | Ahorro de espacio |
| **Restic** | Moderno | Rápido, seguro, eficiente | Backups modernos |

#### Herramientas en Windows

| Herramienta | Tipo | Descripción | Caso de uso |
|-------------|------|-------------|-------------|
| **Windows Backup** | Nativa | Herramienta integrada | Usuarios domésticos |
| **Veeam Agent** | Empresarial | Backup y recuperación profesional | Empresas |
| **Acronis** | Comercial | Suite completa de backup | Entornos mixtos |
| **Robocopy** | Línea de comandos | Copia robusta de archivos | Scripts automatizados |
| **ShadowCopy** | Nativa | Copias de volumen en sombra | Restauración rápida |

### Ejemplos prácticos de comandos

#### Usando rsync para copias incrementales

```bash
# Copia incremental local
rsync -avz --delete /origen/ /destino/

# Copia incremental remota via SSH
rsync -avz --delete /datos/ usuario@servidor:/backup/datos/

# Copia con exclusiones
rsync -avz --exclude='*.tmp' --exclude='cache/' /origen/ /destino/

# Copia con compresión y progreso
rsync -avz --progress --stats /origen/ /destino/

# Backup con hardlinks (ahorra espacio)
rsync -avz --link-dest=/backup/anterior/ /datos/ /backup/actual/
```

#### Usando tar para archivos comprimidos

```bash
# Crear backup comprimido
tar -czf backup-$(date +%Y%m%d).tar.gz /datos/

# Crear backup con exclusiones
tar -czf backup.tar.gz --exclude='*.log' --exclude='temp/*' /datos/

# Backup incremental con tar
tar -czf backup-inc.tar.gz --listed-incremental=snapshot.file /datos/

# Verificar integridad del backup
tar -tzf backup.tar.gz

# Extraer backup
tar -xzf backup.tar.gz -C /restaurar/
```

#### Usando Borgbackup (deduplicación)

```bash
# Inicializar repositorio
borg init --encryption=repokey /ruta/al/repo

# Crear backup
borg create /ruta/al/repo::backup-{now} /datos/

# Listar backups
borg list /ruta/al/repo

# Restaurar backup específico
borg extract /ruta/al/repo::backup-2025-10-17

# Eliminar backups antiguos (mantener últimos 7 días, 4 semanas, 12 meses)
borg prune --keep-daily=7 --keep-weekly=4 --keep-monthly=12 /ruta/al/repo
```

#### Usando Restic (moderno y eficiente)

```bash
# Inicializar repositorio
restic init --repo /backup/repo

# Crear backup
restic backup /datos/ --repo /backup/repo

# Listar snapshots
restic snapshots --repo /backup/repo

# Restaurar snapshot específico
restic restore latest --repo /backup/repo --target /restaurar/

# Verificar integridad
restic check --repo /backup/repo

# Eliminar snapshots antiguos
restic forget --keep-daily 7 --keep-weekly 4 --repo /backup/repo
```

#### Usando PowerShell en Windows

```powershell
# Backup usando Windows Backup
wbadmin start backup -backupTarget:E: -include:C: -allCritical -quiet

# Backup con Robocopy (incremental)
robocopy C:\Datos E:\Backup /MIR /Z /LOG:backup.log

# Crear copia de sombra (VSS)
$shadow = (Get-WmiObject -List Win32_ShadowCopy).Create("C:\", "ClientAccessible")

# Backup usando PowerShell nativo
Copy-Item -Path C:\Datos\* -Destination E:\Backup\ -Recurse -Force

# Comprimir y archivar
Compress-Archive -Path C:\Datos\* -DestinationPath E:\Backup\datos-$(Get-Date -Format 'yyyyMMdd').zip
```

### Script automatizado de backup (Linux)

```bash
#!/bin/bash
# Script de backup completo con verificación

# Configuración
ORIGEN="/datos"
DESTINO="/backup"
FECHA=$(date +%Y%m%d_%H%M%S)
LOG="/var/log/backup-$FECHA.log"
ADMIN_EMAIL="admin@empresa.com"

# Función de log
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG"
}

# Inicio del backup
log "Iniciando backup de $ORIGEN"

# Crear directorio de destino
mkdir -p "$DESTINO/$FECHA"

# Realizar backup con rsync
if rsync -avz --delete "$ORIGEN/" "$DESTINO/$FECHA/" >> "$LOG" 2>&1; then
    log "Backup completado exitosamente"
    
    # Verificar integridad
    if rsync -avz --dry-run --checksum "$ORIGEN/" "$DESTINO/$FECHA/" >> "$LOG" 2>&1; then
        log "Verificación de integridad: OK"
    else
        log "ERROR: Falló la verificación de integridad"
        echo "Error en verificación" | mail -s "Backup ERROR" "$ADMIN_EMAIL"
        exit 1
    fi
    
    # Eliminar backups antiguos (más de 30 días)
    find "$DESTINO" -maxdepth 1 -type d -mtime +30 -exec rm -rf {} \;
    log "Backups antiguos eliminados"
    
    # Notificar éxito
    echo "Backup completado: $FECHA" | mail -s "Backup OK" "$ADMIN_EMAIL"
else
    log "ERROR: Falló el backup"
    echo "Error en backup" | mail -s "Backup ERROR" "$ADMIN_EMAIL"
    exit 1
fi

log "Proceso finalizado"
```

### Script automatizado de backup (Windows PowerShell)

```powershell
# Script de backup automatizado para Windows
param(
    [string]$Origen = "C:\Datos",
    [string]$Destino = "E:\Backup",
    [string]$AdminEmail = "admin@empresa.com"
)

$Fecha = Get-Date -Format "yyyyMMdd_HHmmss"
$LogFile = "C:\Logs\backup-$Fecha.log"
$BackupPath = Join-Path $Destino $Fecha

# Función de log
function Write-Log {
    param([string]$Message)
    $TimeStamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$TimeStamp - $Message" | Tee-Object -FilePath $LogFile -Append
}

try {
    Write-Log "Iniciando backup de $Origen"
    
    # Crear directorio de destino
    New-Item -ItemType Directory -Path $BackupPath -Force | Out-Null
    
    # Realizar backup con Robocopy
    $RobocopyArgs = @(
        $Origen,
        $BackupPath,
        "/MIR",
        "/Z",
        "/R:3",
        "/W:5",
        "/LOG+:$LogFile"
    )
    
    $Result = robocopy @RobocopyArgs
    
    if ($LASTEXITCODE -le 7) {
        Write-Log "Backup completado exitosamente"
        
        # Eliminar backups antiguos (más de 30 días)
        Get-ChildItem $Destino -Directory | 
            Where-Object { $_.CreationTime -lt (Get-Date).AddDays(-30) } |
            Remove-Item -Recurse -Force
        
        Write-Log "Backups antiguos eliminados"
        
        # Notificar éxito
        Send-MailMessage -To $AdminEmail -Subject "Backup OK" `
            -Body "Backup completado: $Fecha" -SmtpServer "smtp.empresa.com"
    }
    else {
        throw "Robocopy falló con código: $LASTEXITCODE"
    }
}
catch {
    Write-Log "ERROR: $($_.Exception.Message)"
    Send-MailMessage -To $AdminEmail -Subject "Backup ERROR" `
        -Body "Error en backup: $($_.Exception.Message)" -SmtpServer "smtp.empresa.com"
    exit 1
}

Write-Log "Proceso finalizado"
```

### Verificación de copias de seguridad

La verificación es un paso crítico que muchas veces se olvida:

**Métodos de verificación:**

1. **Verificación de integridad (checksum)**
   ```bash
   # Generar checksums
   find /backup -type f -exec sha256sum {} \; > checksums.txt
   
   # Verificar checksums
   sha256sum -c checksums.txt
   ```

2. **Pruebas de restauración parcial**
   ```bash
   # Restaurar archivo aleatorio y comparar
   rsync -avz /backup/archivo.txt /tmp/test/
   diff /datos/archivo.txt /tmp/test/archivo.txt
   ```

3. **Restauración completa en entorno de prueba**
   - Realizar restauración completa periódicamente
   - Verificar funcionalidad de aplicaciones
   - Documentar tiempo de recuperación

:::warning Importante
**Nunca asumas que un backup funciona sin haberlo verificado.** Un backup no verificado es tan útil como no tener backup. Establece un calendario regular de pruebas de restauración.
:::   

### Realización de copias de seguridad en sistemas en funcionamiento

Realizar copias de seguridad en sistemas en funcionamiento (**hot backups**) es esencial para minimizar el tiempo de inactividad y asegurar la continuidad del negocio. 

#### Tipos de backups según disponibilidad del sistema

| Tipo | Nombre | Estado del sistema | Consistencia | Uso típico |
|------|--------|-------------------|--------------|------------|
| **Hot Backup** | En caliente | En funcionamiento | Requiere técnicas especiales | Sistemas 24/7 críticos |
| **Warm Backup** | Templado | Funcionamiento limitado | Buena | Sistemas con ventanas pequeñas |
| **Cold Backup** | En frío | Sistema apagado | Perfecta | Sistemas no críticos |

#### Técnicas para hot backups

**1. Volume Shadow Copy Service (VSS) - Windows**

VSS permite crear copias consistentes de volúmenes mientras el sistema está en uso.

```powershell
# Listar copias de sombra existentes
vssadmin list shadows

# Crear copia de sombra del volumen C:
vssadmin create shadow /for=C:

# Crear snapshot con PowerShell
$class = [WMICLASS]"root\cimv2:Win32_ShadowCopy"
$class.Create("C:\", "ClientAccessible")

# Backup usando VSS y Robocopy
$volume = "C:"
$backup = "E:\Backup"
$shadow = (Get-WmiObject -List Win32_ShadowCopy).Create($volume, "ClientAccessible")
$shadowPath = $shadow.ShadowCopyVolume
robocopy $shadowPath $backup /MIR /R:3
```

**2. LVM Snapshots - Linux**

Los snapshots de LVM permiten capturar el estado de un volumen lógico en un momento específico.

```bash
# Crear snapshot de un volumen LVM
lvcreate --size 10G --snapshot --name backup-snap /dev/vg0/datos

# Montar el snapshot
mkdir /mnt/snapshot
mount /dev/vg0/backup-snap /mnt/snapshot

# Realizar backup del snapshot
tar -czf /backup/datos-$(date +%Y%m%d).tar.gz -C /mnt/snapshot .

# Desmontar y eliminar snapshot
umount /mnt/snapshot
lvremove -f /dev/vg0/backup-snap
```

**3. Snapshots de sistemas de archivos (ZFS, Btrfs)**

```bash
# ZFS Snapshot
zfs snapshot pool/datos@backup-$(date +%Y%m%d)

# Listar snapshots
zfs list -t snapshot

# Enviar snapshot a otro sistema
zfs send pool/datos@backup-20251017 | ssh remote zfs receive backup/datos

# Btrfs Snapshot
btrfs subvolume snapshot /datos /snapshots/datos-$(date +%Y%m%d)

# Listar snapshots de Btrfs
btrfs subvolume list /
```

**4. Backup de bases de datos en caliente**

**MySQL/MariaDB:**
```bash
# Backup con mysqldump (bloqueo corto)
mysqldump -u root -p --single-transaction --routines --triggers \
  --all-databases > backup-$(date +%Y%m%d).sql

# Backup con Percona XtraBackup (sin bloqueo)
xtrabackup --backup --target-dir=/backup/mysql/

# Backup incremental con XtraBackup
xtrabackup --backup --target-dir=/backup/incremental \
  --incremental-basedir=/backup/full
```

**PostgreSQL:**
```bash
# Backup con pg_dump
pg_dump -U postgres -Fc database_name > backup.dump

# Backup de todas las bases de datos
pg_dumpall -U postgres > backup-all.sql

# Backup continuo con WAL archiving
# En postgresql.conf:
# archive_mode = on
# archive_command = 'cp %p /backup/archive/%f'

# Realizar backup base
pg_basebackup -D /backup/base -Ft -z -P
```

**MongoDB:**
```bash
# Backup con mongodump
mongodump --out=/backup/mongo-$(date +%Y%m%d)

# Backup de base de datos específica
mongodump --db=mibasedatos --out=/backup/

# Backup con oplog (point-in-time recovery)
mongodump --oplog --out=/backup/mongo-oplog
```

**SQL Server:**
```sql
-- Backup completo sin afectar operaciones
BACKUP DATABASE [MiBaseDatos] 
TO DISK = 'C:\Backup\MiBaseDatos.bak' 
WITH INIT, COMPRESSION, STATS = 10;

-- Backup incremental (transaction log)
BACKUP LOG [MiBaseDatos]
TO DISK = 'C:\Backup\MiBaseDatos_log.trn'
WITH INIT, COMPRESSION;
```

#### Consideraciones para hot backups

**1. Consistencia de datos**

- **Quiescing de aplicaciones**: Poner aplicaciones en estado consistente antes del snapshot
- **Flush de caché**: Asegurar que datos en memoria se escriban a disco
- **Coordinación de transacciones**: Asegurar que transacciones se completen

```bash
# Ejemplo: Sincronizar filesystem antes de snapshot
sync
echo 3 > /proc/sys/vm/drop_caches  # Limpiar caché
lvcreate --snapshot ...  # Crear snapshot
```

**2. Impacto en el rendimiento**

| Técnica | Impacto en CPU | Impacto en I/O | Impacto en memoria | Duración impacto |
|---------|----------------|----------------|-------------------|------------------|
| **VSS/Snapshot** | Bajo | Medio | Bajo | Segundos |
| **Backup directo** | Medio | Alto | Bajo | Horas |
| **Replicación** | Medio | Medio | Medio | Continuo |
| **CDP** | Alto | Bajo | Alto | Continuo |

**Estrategias de minimización:**

- **Programar en horas valle**: Realizar backups cuando la carga es menor
- **Limitación de ancho de banda**: Usar herramientas con throttling
- **Prioridad de procesos**: Ajustar nice/ionice en Linux
- **Backup incremental**: Copiar solo cambios

```bash
# Rsync con límite de ancho de banda
rsync -avz --bwlimit=10000 /datos/ /backup/  # 10MB/s máximo

# Rsync con baja prioridad de I/O
ionice -c 3 rsync -avz /datos/ /backup/

# Rsync con baja prioridad de CPU
nice -n 19 rsync -avz /datos/ /backup/
```

**3. Monitoreo y alertas**

Implementar monitoreo completo del proceso de backup:

```bash
#!/bin/bash
# Script de monitoreo de backup

BACKUP_DIR="/backup"
MAX_AGE_HOURS=26
ALERT_EMAIL="admin@empresa.com"

# Verificar antigüedad del último backup
LAST_BACKUP=$(find $BACKUP_DIR -type f -name "*.tar.gz" -printf '%T@ %p\n' | \
  sort -n | tail -1 | cut -f2- -d" ")

if [ -z "$LAST_BACKUP" ]; then
    echo "ERROR: No se encontraron backups" | mail -s "ALERTA: Backup" $ALERT_EMAIL
    exit 1
fi

BACKUP_AGE=$(( ($(date +%s) - $(stat -c %Y "$LAST_BACKUP")) / 3600 ))

if [ $BACKUP_AGE -gt $MAX_AGE_HOURS ]; then
    echo "ERROR: Último backup tiene $BACKUP_AGE horas" | \
      mail -s "ALERTA: Backup antiguo" $ALERT_EMAIL
    exit 1
fi

# Verificar espacio disponible
SPACE_AVAILABLE=$(df -h $BACKUP_DIR | awk 'NR==2 {print $5}' | sed 's/%//')

if [ $SPACE_AVAILABLE -gt 90 ]; then
    echo "ADVERTENCIA: Espacio de backup al ${SPACE_AVAILABLE}%" | \
      mail -s "ALERTA: Espacio disco backup" $ALERT_EMAIL
fi

echo "Backup OK: $LAST_BACKUP ($BACKUP_AGE horas)"
```

**4. Continuous Data Protection (CDP)**

CDP proporciona backups continuos con RPO (Recovery Point Objective) cercano a cero.

**Herramientas CDP:**
- **Zerto**: Replicación continua para virtualización
- **Veeam CDP**: Para entornos VMware
- **DRBD**: Replicación a nivel de bloque en Linux
- **Azure Site Recovery**: CDP para Azure

**Ventajas de CDP:**
- RPO muy bajo (segundos o minutos)
- Múltiples puntos de recuperación
- Recuperación granular

**Desventajas:**
- Mayor costo
- Mayor complejidad
- Requiere más recursos

#### Mejores prácticas para hot backups

1. **Usar snapshots cuando sea posible**: Minimizan el tiempo de inconsistencia
2. **Coordinar con aplicaciones**: Usar APIs de aplicaciones para backups consistentes
3. **Verificar consistencia**: Validar que los backups son recuperables
4. **Documentar procedimientos**: Mantener runbooks actualizados
5. **Monitorear impacto**: Ajustar según el rendimiento del sistema
6. **Probar restauraciones**: Validar regularmente el proceso de recovery

:::tip Recomendación
Para sistemas críticos 24/7, considera implementar una estrategia híbrida:
- **Snapshots frecuentes** (cada hora) para RPO bajo
- **Backups incrementales** (diarios) para retención
- **Backups completos** (semanales) para recuperación rápida
- **Replicación remota** (continua) para disaster recovery
:::   

## Creación y restauración de imágenes de respaldo de sistemas en funcionamiento

La creación y restauración de imágenes de respaldo (también conocidas como **clones** o **imágenes de disco**) permite capturar el estado completo de un sistema, incluyendo el sistema operativo, aplicaciones, configuraciones y datos. Esta técnica es fundamental para la recuperación rápida ante desastres.

### Conceptos clave

**Imagen de disco vs Backup de archivos:**

| Característica | Imagen de disco | Backup de archivos |
|----------------|-----------------|-------------------|
| **Contenido** | Sistema completo (sector por sector) | Solo archivos y carpetas seleccionados |
| **Booteable** | Sí, puede arrancar directamente | No, requiere sistema operativo |
| **Tamaño** | Mayor (incluye espacio vacío) | Menor (solo datos actuales) |
| **Velocidad de recuperación** | Muy rápida | Más lenta |
| **Flexibilidad** | Baja (restaura todo) | Alta (restaura selectivamente) |
| **Uso típico** | Disaster recovery | Recuperación de archivos específicos |

### Herramientas para creación de imágenes

#### Herramientas en Linux

| Herramienta | Tipo | Características | Nivel |
|-------------|------|-----------------|-------|
| **dd** | Línea de comandos | Copia bit a bit, básico | Avanzado |
| **Clonezilla** | GUI/TUI | Gratuito, completo, muy popular | Todos |
| **Partclone** | Línea de comandos | Solo copia bloques usados | Intermedio |
| **FSArchiver** | Línea de comandos | Copia a nivel de sistema de archivos | Intermedio |
| **Mondo Rescue** | TUI | Disaster recovery completo | Avanzado |
| **ReaR** | Línea de comandos | Relax-and-Recover | Avanzado |

#### Herramientas en Windows

| Herramienta | Tipo | Características | Coste |
|-------------|------|-----------------|-------|
| **Windows Backup** | Nativo | Imagen del sistema integrada | Gratuito |
| **Macrium Reflect** | GUI | Potente y fiable | Freemium |
| **Acronis True Image** | GUI | Suite completa profesional | Comercial |
| **Veeam Agent** | GUI | Empresarial, muy completo | Freemium |
| **Clonezilla** | TUI | Multiplataforma, gratuito | Gratuito |
| **DISM** | Línea de comandos | Nativo de Windows | Gratuito |

### Proceso de creación de imagen

#### 1. Preparación del sistema

Antes de crear la imagen, preparar el sistema:

```bash
# Linux: Limpiar archivos temporales
sudo apt-get clean
sudo rm -rf /tmp/*
sudo rm -rf /var/tmp/*

# Compactar logs
sudo journalctl --vacuum-time=7d

# Llenar espacio libre con ceros (mejora compresión)
sudo dd if=/dev/zero of=/ceros bs=1M
sudo rm -f /ceros
```

```powershell
# Windows: Limpiar archivos temporales
cleanmgr /sagerun:1

# Desfragmentar (solo HDD, no SSD)
Optimize-Volume -DriveLetter C -Defragment

# Limpiar archivos del sistema
Dism /Online /Cleanup-Image /StartComponentCleanup
```

#### 2. Creación de imagen con dd (Linux)

```bash
# Imagen de disco completo
sudo dd if=/dev/sda of=/backup/disk-image.img bs=64K status=progress

# Imagen comprimida con gzip
sudo dd if=/dev/sda bs=64K status=progress | gzip -c > /backup/disk-image.img.gz

# Imagen comprimida con mayor eficiencia (pipe a través de SSH)
sudo dd if=/dev/sda bs=64K status=progress | \
  gzip -c | \
  ssh usuario@servidor "cat > /backup/disk-image.img.gz"

# Imagen solo de partición
sudo dd if=/dev/sda1 of=/backup/partition-image.img bs=64K status=progress

# Verificar integridad de la imagen
md5sum /dev/sda > /backup/sda.md5
md5sum /backup/disk-image.img >> /backup/sda.md5
```

#### 3. Creación de imagen con Clonezilla

**Modo por línea de comandos:**
```bash
# Instalar Clonezilla
sudo apt-get install clonezilla

# Crear imagen de disco
sudo /usr/sbin/ocs-sr -q2 -c -j2 -z1p -i 4096 -fsck-src-part -p true \
  savedisk imagen-nombre sda

# Crear imagen de partición específica
sudo /usr/sbin/ocs-sr -q2 -c -j2 -z1p -i 4096 \
  saveparts imagen-nombre sda1
```

**Modo interactivo (Live CD):**
1. Arrancar desde USB/CD de Clonezilla
2. Seleccionar idioma y teclado
3. Elegir "device-image" (guardar/restaurar disco/partición)
4. Seleccionar ubicación de almacenamiento (local, SSH, Samba, NFS)
5. Elegir modo: "Beginner" o "Expert"
6. Seleccionar "savedisk" o "saveparts"
7. Configurar opciones de compresión y verificación
8. Confirmar y esperar finalización

#### 4. Creación de imagen con Partclone

```bash
# Instalar partclone
sudo apt-get install partclone

# Imagen de partición ext4
sudo partclone.ext4 -c -s /dev/sda1 -o /backup/sda1.img

# Imagen con compresión
sudo partclone.ext4 -c -s /dev/sda1 | \
  gzip -c > /backup/sda1.img.gz

# Imagen directa a dispositivo remoto
sudo partclone.ext4 -c -s /dev/sda1 | \
  ssh usuario@servidor "cat > /backup/sda1.img"
```

#### 5. Creación de imagen en Windows

**Usando Windows Backup (GUI):**
1. Panel de Control → Backup and Restore (Windows 7)
2. Crear imagen del sistema
3. Seleccionar ubicación (disco externo, red)
4. Confirmar y esperar finalización

**Usando DISM (línea de comandos):**
```powershell
# Capturar imagen de Windows
Dism /Capture-Image /ImageFile:C:\backup\install.wim \
  /CaptureDir:D:\ /Name:"Windows Backup"

# Capturar con compresión máxima
Dism /Capture-Image /ImageFile:C:\backup\install.wim \
  /CaptureDir:D:\ /Name:"Windows Backup" /Compress:max

# Verificar imagen
Dism /Get-ImageInfo /ImageFile:C:\backup\install.wim
```

**Usando Macrium Reflect:**
```powershell
# Por línea de comandos
"C:\Program Files\Macrium\Reflect\reflect.exe" \
  -e -w "C:\backup\backup-$(Get-Date -Format 'yyyyMMdd').mrimg" \
  -full "0:1"
```

### Proceso de restauración de imagen

#### Restauración con dd (Linux)

```bash
# Restaurar imagen completa
sudo dd if=/backup/disk-image.img of=/dev/sda bs=64K status=progress

# Restaurar imagen comprimida
gunzip -c /backup/disk-image.img.gz | \
  sudo dd of=/dev/sda bs=64K status=progress

# Restaurar desde servidor remoto
ssh usuario@servidor "cat /backup/disk-image.img.gz" | \
  gunzip -c | \
  sudo dd of=/dev/sda bs=64K status=progress

# Verificar después de restaurar
sudo fsck -n /dev/sda1
```

#### Restauración con Clonezilla

**Modo por línea de comandos:**
```bash
# Restaurar disco completo
sudo /usr/sbin/ocs-sr -g auto -e1 auto -e2 -r -j2 -p true \
  restoredisk imagen-nombre sda

# Restaurar partición específica
sudo /usr/sbin/ocs-sr -g auto -e1 auto -e2 -r \
  restoreparts imagen-nombre sda1
```

**Modo interactivo:**
1. Arrancar desde Live CD de Clonezilla
2. Elegir "device-image"
3. Seleccionar ubicación de la imagen
4. Elegir "restoredisk" o "restoreparts"
5. Seleccionar imagen a restaurar
6. Confirmar dispositivo de destino
7. Confirmar y esperar finalización

:::danger Precaución
La restauración de una imagen **SOBREESCRIBIRÁ COMPLETAMENTE** el disco o partición de destino. Asegúrate de haber seleccionado el dispositivo correcto. Los datos existentes se perderán permanentemente.
:::

#### Restauración con Partclone

```bash
# Restaurar partición desde imagen
sudo partclone.ext4 -r -s /backup/sda1.img -o /dev/sda1

# Restaurar desde imagen comprimida
gunzip -c /backup/sda1.img.gz | \
  sudo partclone.ext4 -r -s - -o /dev/sda1

# Restaurar desde servidor remoto
ssh usuario@servidor "cat /backup/sda1.img" | \
  sudo partclone.ext4 -r -s - -o /dev/sda1
```

#### Restauración en Windows

**Usando Windows Recovery Environment:**
1. Arrancar desde USB/DVD de instalación de Windows
2. Elegir "Reparar el equipo"
3. Solucionar problemas → Opciones avanzadas
4. Recuperación de imagen del sistema
5. Seleccionar imagen de copia de seguridad
6. Configurar opciones y confirmar

**Usando DISM:**
```powershell
# Aplicar imagen de Windows
Dism /Apply-Image /ImageFile:C:\backup\install.wim \
  /Index:1 /ApplyDir:D:\

# Reconstruir BCD (Boot Configuration Data)
bcdboot D:\Windows /s S:
```

### Escenarios de uso de imágenes

#### 1. Disaster Recovery

**Escenario:** Fallo catastrófico de disco o sistema corrupto

**Solución:**
1. Reemplazar hardware defectuoso si es necesario
2. Arrancar desde medio de recuperación (Clonezilla, Windows RE)
3. Restaurar imagen más reciente
4. Verificar funcionamiento
5. Aplicar cambios incrementales si existen

**RTO (Recovery Time Objective):** 1-4 horas dependiendo del tamaño

#### 2. Clonación de sistemas

**Escenario:** Desplegar mismo sistema en múltiples equipos

**Solución:**
1. Configurar sistema maestro (golden image)
2. Sysprep en Windows / generalizar en Linux
3. Crear imagen del sistema maestro
4. Restaurar imagen en equipos destino
5. Personalizar cada sistema (hostname, IP, etc.)

**Ventajas:**
- Despliegue rápido y consistente
- Reduce errores de configuración
- Ahorra tiempo en configuraciones repetitivas

#### 3. Migración de hardware

**Escenario:** Mover sistema a hardware diferente

**Proceso Windows:**
```powershell
# 1. Crear imagen en hardware antiguo
# 2. Restaurar en nuevo hardware
# 3. Reparar controladores
Dism /Image:C:\ /Add-Driver /Driver:D:\Drivers /Recurse

# 4. Reconstruir BCD si es necesario
bootrec /fixmbr
bootrec /fixboot
bootrec /rebuildbcd
```

**Proceso Linux:**
```bash
# 1. Crear imagen
# 2. Restaurar en nuevo hardware
# 3. Actualizar initramfs
sudo update-initramfs -u -k all

# 4. Reinstalar GRUB
sudo grub-install /dev/sda
sudo update-grub
```

#### 4. Testing y desarrollo

**Escenario:** Crear entornos de prueba idénticos

**Solución:**
1. Crear imagen del entorno de producción
2. Restaurar en VM o hardware de prueba
3. Realizar pruebas sin afectar producción
4. Destruir y recrear según necesidad

### Mejores prácticas para imágenes de respaldo

#### 1. Planificación

- **Frecuencia:** Crear imágenes después de cambios significativos
  - Después de actualizaciones importantes
  - Antes de cambios críticos de configuración
  - Mensualmente para sistemas estables
  - Semanalmente para sistemas en desarrollo

- **Retención:** Mantener múltiples versiones
  ```
  Última imagen:        Siempre disponible
  Imagen semanal:       4 semanas
  Imagen mensual:       12 meses
  Imagen anual:         3-5 años
  ```

#### 2. Verificación

**Verificar integridad de la imagen:**
```bash
# Crear checksum al crear imagen
md5sum /backup/disk-image.img > /backup/disk-image.img.md5

# Verificar antes de restaurar
md5sum -c /backup/disk-image.img.md5

# Verificar montando la imagen (Linux)
sudo kpartx -av /backup/disk-image.img
sudo mount /dev/mapper/loop0p1 /mnt/verify
ls /mnt/verify  # Verificar contenido
sudo umount /mnt/verify
sudo kpartx -dv /backup/disk-image.img
```

**Verificar restauración en entorno de prueba:**
- Restaurar periódicamente en VM
- Verificar que el sistema arranca
- Probar funcionalidad de aplicaciones críticas
- Documentar tiempo de recuperación

#### 3. Almacenamiento

- **Múltiples ubicaciones:** Aplicar regla 3-2-1
  - 1 imagen en disco local (recuperación rápida)
  - 1 imagen en NAS/servidor (protección local)
  - 1 imagen en cloud/off-site (disaster recovery)

- **Seguridad:** Cifrar imágenes sensibles
  ```bash
  # Cifrar con GPG
  gpg --symmetric --cipher-algo AES256 disk-image.img
  
  # Descifrar
  gpg --decrypt disk-image.img.gpg > disk-image.img
  ```

#### 4. Documentación

Mantener documentación detallada:
```markdown
# Documentación de Imagen de Respaldo

## Información de la imagen
- **Fecha de creación:** 2025-10-17
- **Sistema:** Ubuntu Server 22.04 LTS
- **Hostname:** servidor-produccion
- **Tamaño:** 45 GB (comprimido: 18 GB)
- **Ubicación:** /backup/images/servidor-2025-10-17.img.gz
- **Checksum MD5:** a1b2c3d4e5f6...
- **Herramienta:** Clonezilla 3.1.0

## Contenido
- SO: Ubuntu 22.04
- Aplicaciones: Apache, MySQL, PHP
- Configuraciones: /etc/*
- Datos: /var/www, /var/lib/mysql

## Procedimiento de restauración
1. Arrancar desde Clonezilla Live USB
2. Seleccionar imagen: servidor-2025-10-17
3. Restaurar en /dev/sda
4. Reconfigurar IP si es necesario
5. Verificar servicios: systemctl status apache2 mysql

## Tiempo estimado de recuperación
- Restauración: 1.5 horas
- Verificación: 30 minutos
- **RTO total:** 2 horas

## Contactos
- Responsable: admin@empresa.com
- Backup location: backup-server.empresa.local
```

### Automatización de creación de imágenes

**Script automatizado (Linux):**
```bash
#!/bin/bash
# Script de creación automática de imagen de sistema

HOSTNAME=$(hostname)
FECHA=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/images"
IMAGEN="$BACKUP_DIR/${HOSTNAME}_${FECHA}.img.gz"
LOG="$BACKUP_DIR/${HOSTNAME}_${FECHA}.log"
EMAIL="admin@empresa.com"

# Crear directorio si no existe
mkdir -p "$BACKUP_DIR"

# Iniciar log
echo "=== Inicio de imagen de sistema ===" > "$LOG"
echo "Fecha: $(date)" >> "$LOG"
echo "Hostname: $HOSTNAME" >> "$LOG"

# Limpiar sistema
echo "Limpiando archivos temporales..." | tee -a "$LOG"
apt-get clean
rm -rf /tmp/*
rm -rf /var/tmp/*

# Crear imagen
echo "Creando imagen del disco..." | tee -a "$LOG"
if dd if=/dev/sda bs=64K status=progress 2>> "$LOG" | \
   gzip -c > "$IMAGEN"; then
    
    # Calcular checksum
    echo "Calculando checksum..." | tee -a "$LOG"
    md5sum "$IMAGEN" > "${IMAGEN}.md5"
    
    # Información de la imagen
    TAMANIO=$(du -h "$IMAGEN" | cut -f1)
    echo "Imagen creada exitosamente" | tee -a "$LOG"
    echo "Tamaño: $TAMANIO" | tee -a "$LOG"
    
    # Eliminar imágenes antiguas (más de 30 días)
    find "$BACKUP_DIR" -name "*.img.gz" -mtime +30 -delete
    
    # Enviar notificación
    echo "Imagen de $HOSTNAME creada: $TAMANIO" | \
      mail -s "Imagen de sistema OK" "$EMAIL"
else
    echo "ERROR: Falló la creación de imagen" | tee -a "$LOG"
    echo "Error al crear imagen de $HOSTNAME" | \
      mail -s "ERROR: Imagen de sistema" "$EMAIL"
    exit 1
fi

echo "=== Proceso finalizado ===" | tee -a "$LOG"
```

:::tip Recomendación
Para entornos de producción críticos, combina múltiples estrategias:
1. **Imágenes completas** mensuales para disaster recovery rápido
2. **Backups incrementales** diarios para recuperación granular de archivos
3. **Snapshots** frecuentes (horarios) para puntos de recuperación cercanos
4. **Replicación** continua a sitio secundario para alta disponibilidad

Esta estrategia en capas proporciona el balance óptimo entre RTO, RPO y uso de recursos.
:::

## Plan de recuperación ante desastres (DRP)

Un plan de recuperación ante desastres es fundamental para garantizar la continuidad del negocio. Las copias de seguridad e imágenes son componentes críticos de este plan.

### Componentes del DRP

#### 1. Objetivos de recuperación

**RPO (Recovery Point Objective):**
- Cantidad máxima de datos que se puede perder
- Medido en tiempo (ej: 1 hora, 24 horas)
- Determina la frecuencia de backups

**RTO (Recovery Time Objective):**
- Tiempo máximo de inactividad aceptable
- Medido en tiempo (ej: 4 horas, 1 día)
- Determina el método de recuperación

| Criticidad | RPO | RTO | Estrategia recomendada |
|------------|-----|-----|------------------------|
| **Crítica** | < 1 hora | < 4 horas | Replicación + CDP + Imágenes |
| **Alta** | < 4 horas | < 8 horas | Snapshots horarios + GFS |
| **Media** | < 24 horas | < 24 horas | Backups diarios + Imágenes semanales |
| **Baja** | < 1 semana | < 3 días | Backups semanales |

#### 2. Escenarios de desastre

**Niveles de desastre:**

1. **Nivel 1 - Pérdida de archivo individual**
   - Impacto: Mínimo
   - Solución: Restauración de archivo desde backup
   - Tiempo: Minutos

2. **Nivel 2 - Corrupción de datos/aplicación**
   - Impacto: Bajo-Medio
   - Solución: Restauración de aplicación o datos específicos
   - Tiempo: Horas

3. **Nivel 3 - Fallo de servidor**
   - Impacto: Alto
   - Solución: Restauración de imagen completa
   - Tiempo: Horas

4. **Nivel 4 - Fallo de sitio completo**
   - Impacto: Crítico
   - Solución: Failover a sitio secundario
   - Tiempo: Horas-Días

#### 3. Procedimientos de recuperación

**Checklist de recuperación:**

```markdown
## Procedimiento de Recuperación de Desastre

### Fase 1: Evaluación (15-30 min)
- [ ] Identificar tipo y alcance del desastre
- [ ] Determinar sistemas afectados
- [ ] Activar equipo de respuesta
- [ ] Comunicar a stakeholders
- [ ] Documentar incidente

### Fase 2: Contención (30-60 min)
- [ ] Aislar sistemas afectados
- [ ] Prevenir propagación del problema
- [ ] Preservar evidencia para análisis
- [ ] Activar sistemas de respaldo si están disponibles

### Fase 3: Recuperación (2-24 horas)
- [ ] Identificar backup/imagen más reciente válido
- [ ] Verificar integridad de backup
- [ ] Preparar hardware de destino
- [ ] Iniciar proceso de restauración
- [ ] Monitorear progreso de restauración

### Fase 4: Verificación (1-2 horas)
- [ ] Verificar sistema arranca correctamente
- [ ] Probar funcionalidad de aplicaciones críticas
- [ ] Verificar integridad de datos
- [ ] Confirmar conectividad de red
- [ ] Validar acceso de usuarios

### Fase 5: Puesta en producción (30-60 min)
- [ ] Comunicar restauración a usuarios
- [ ] Habilitar acceso al sistema
- [ ] Monitorear rendimiento inicial
- [ ] Reactivar backups automáticos
- [ ] Actualizar documentación

### Fase 6: Post-mortem (1-7 días)
- [ ] Analizar causa raíz
- [ ] Documentar lecciones aprendidas
- [ ] Actualizar procedimientos
- [ ] Implementar mejoras preventivas
- [ ] Comunicar resultados a dirección
```

### Plan de pruebas de recuperación

**Calendario de pruebas recomendado:**

| Tipo de prueba | Frecuencia | Alcance | Duración |
|----------------|-----------|---------|----------|
| **Restauración de archivo** | Mensual | Archivos individuales | 30 min |
| **Restauración de aplicación** | Trimestral | Aplicación completa | 2 horas |
| **Restauración de sistema** | Semestral | Sistema completo | 4 horas |
| **Simulacro completo** | Anual | Toda la infraestructura | 1 día |

**Script de verificación automática:**

```bash
#!/bin/bash
# Verificación automática de recuperabilidad de backups

BACKUP_DIR="/backup"
TEST_RESTORE_DIR="/tmp/test-restore"
LOG_FILE="/var/log/backup-test.log"

echo "=== Inicio prueba de recuperación $(date) ===" >> "$LOG_FILE"

# Seleccionar backup aleatorio
BACKUP=$(find "$BACKUP_DIR" -name "*.tar.gz" | shuf -n 1)
echo "Probando backup: $BACKUP" >> "$LOG_FILE"

# Crear directorio temporal
mkdir -p "$TEST_RESTORE_DIR"

# Intentar extraer
if tar -xzf "$BACKUP" -C "$TEST_RESTORE_DIR" 2>> "$LOG_FILE"; then
    echo "✓ Extracción exitosa" >> "$LOG_FILE"
    
    # Verificar algunos archivos clave
    if [ -f "$TEST_RESTORE_DIR/etc/passwd" ]; then
        echo "✓ Archivos del sistema presentes" >> "$LOG_FILE"
        SUCCESS=true
    else
        echo "✗ Archivos del sistema faltantes" >> "$LOG_FILE"
        SUCCESS=false
    fi
else
    echo "✗ Error al extraer backup" >> "$LOG_FILE"
    SUCCESS=false
fi

# Limpiar
rm -rf "$TEST_RESTORE_DIR"

# Notificar resultado
if [ "$SUCCESS" = true ]; then
    echo "Prueba de backup exitosa" | mail -s "✓ Backup Test OK" admin@empresa.com
else
    echo "ALERTA: Fallo en prueba de backup" | mail -s "✗ Backup Test FAILED" admin@empresa.com
fi

echo "=== Fin prueba de recuperación ===" >> "$LOG_FILE"
```

## Cumplimiento normativo y retención de datos

### Regulaciones comunes

| Regulación | Ámbito | Retención mínima | Requisitos especiales |
|------------|--------|------------------|----------------------|
| **RGPD** | UE - Datos personales | Variable | Derecho al olvido, cifrado |
| **LOPD** | España - Datos personales | Variable | Registro de actividades |
| **HIPAA** | USA - Datos médicos | 6 años | Cifrado, auditoría |
| **SOX** | USA - Datos financieros | 7 años | Inmutabilidad, auditoría |
| **PCI-DSS** | Internacional - Pagos | 1 año activos | Cifrado, segmentación |

### Políticas de retención

**Ejemplo de política de retención:**

```markdown
## Política de Retención de Backups

### Datos de usuarios
- **Backups diarios:** 30 días
- **Backups semanales:** 12 semanas
- **Backups mensuales:** 12 meses
- **Backups anuales:** 7 años

### Datos financieros
- **Backups diarios:** 90 días
- **Backups mensuales:** 7 años
- **Copias de auditoría:** 10 años

### Datos operacionales
- **Backups diarios:** 14 días
- **Backups semanales:** 8 semanas
- **Backups mensuales:** 12 meses

### Imágenes de sistemas
- **Imagen pre-cambio:** 90 días
- **Imagen mensual:** 12 meses
- **Imagen anual:** 3 años

### Eliminación segura
- Sobrescritura con ceros (3 pasadas)
- Certificación de destrucción
- Registro en log de auditoría
```

## Resumen de mejores prácticas

### Comandos útiles de referencia rápida

```bash
# === LINUX ===

# Backup con tar
tar -czf backup-$(date +%Y%m%d).tar.gz /datos/

# Backup con rsync
rsync -avz --delete /datos/ /backup/

# Backup con Borgbackup
borg create /repo::backup-{now} /datos/

# Imagen de disco con dd
dd if=/dev/sda of=/backup/disk.img bs=64K status=progress

# Snapshot LVM
lvcreate -L 10G -s -n snap /dev/vg0/datos

# Snapshot ZFS
zfs snapshot pool/datos@backup-$(date +%Y%m%d)

# Verificar backup
tar -tzf backup.tar.gz
rsync -avz --dry-run --checksum /datos/ /backup/

# === WINDOWS ===

# Backup con Robocopy
robocopy C:\Datos E:\Backup /MIR /Z /LOG:backup.log

# Backup con PowerShell
Copy-Item C:\Datos\* E:\Backup\ -Recurse -Force

# Comprimir archivos
Compress-Archive -Path C:\Datos\* -DestinationPath E:\backup.zip

# Backup de Windows
wbadmin start backup -backupTarget:E: -include:C: -allCritical

# Crear imagen con DISM
Dism /Capture-Image /ImageFile:C:\backup.wim /CaptureDir:D:\
```

### Recursos adicionales

**Herramientas recomendadas:**
- [Bacula](https://www.bacula.org/) - Suite enterprise de backup
- [Restic](https://restic.net/) - Backup moderno y eficiente
- [Borgbackup](https://www.borgbackup.org/) - Backup con deduplicación
- [Clonezilla](https://clonezilla.org/) - Clonación y imaging gratuito
- [Veeam](https://www.veeam.com/) - Solución empresarial completa

**Lecturas recomendadas:**
- Guías de mejores prácticas de NIST
- Documentación de DR de AWS/Azure/GCP
- Estándares ISO 27001 sobre backup
- Regulaciones RGPD sobre retención de datos

:::info Conclusión
Un sistema robusto de copias de seguridad es la última línea de defensa contra la pérdida de datos. La combinación de múltiples estrategias (backups regulares, imágenes de sistema, replicación) junto con pruebas periódicas de restauración garantiza que los datos críticos puedan ser recuperados cuando sea necesario. Recuerda: **un backup no verificado es tan útil como no tener backup**.
:::